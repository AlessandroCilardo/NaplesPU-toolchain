//===-- NaplesPUISelDAGToDAG.cpp - A dag to dag inst selector for NaplesPU ------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass transforms target independent LLVM DAG nodes into platform
// dependent nodes that map, for the most part, directly to target instructions.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "naplespu-isel"

#include "NaplesPUTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

namespace {
class NaplesPUDAGToDAGISel : public SelectionDAGISel {
public:
  explicit NaplesPUDAGToDAGISel(NaplesPUTargetMachine &tm) : SelectionDAGISel(tm) {}

  void Select(SDNode *N) override;

  // Tale funzione è richiamata automaticamente da tablegen indirettamente,
  // chiamando la funzione SelectInlineAsmMemoryOperands.
  /// SelectInlineAsmMemoryOperand - Select the specified address as a target
  /// addressing mode, according to the specified constraint.  If this does
  /// not match or is not implemented, return true.  The resultant operands
  /// (which will appear in the machine instruction) should be added to the
  /// OutOps vector.
  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintCode,
                                    std::vector<SDValue> &OutOps) override;  

  // Complex Pattern Selectors (referenced from TableGen'd instruction matching
  // code)
  bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);

// dichiarata in PassInfo.h Return the friendly name for the pass, never returns null
  StringRef getPassName() const override {
    return "NaplesPU DAG->DAG Pattern Instruction Selection";
  }

// Include the pieces autogenerated from the target description.
#include "NaplesPUGenDAGISel.inc"
};
} // end anonymous namespace

// Da come è stato definito in NaplesPUInstrFormats.td, tale funzione viene
// richiamata quando si incontra un SDValue iptr che si riferisce ad un nodo
// di tipo "frameindex", oppure quando l'SDValue è v16i32 e v8i64, restituendo
// sempre 2 operandi (Base e Offset)
// TODO: Bisogna verificare se è necessario modificare
// la funzione ed se è necessario aggiungere ulteriori Selectxxx per altri
// ComplexPatterns.
bool NaplesPUDAGToDAGISel::SelectADDRri(SDValue Addr, SDValue &Base,
                                     SDValue &Offset) {

 // Se il nodo a cui si riferisce Addr è una foglia di tipo FrameIndex
  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    // Converti Addr in due SDValue Base+Offset, il primo con valore
    // pari al Frameindex e il secondo pari a 0
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
    return true;
  }
  //TODO: controllare le condizioni dell'if
  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
      Addr.getOpcode() == ISD::TargetGlobalAddress)
    return false; // direct calls.
// Se l'operazione del Nodo a cui si riferisce Addr è una ADD


  if (Addr.getOpcode() == ISD::ADD) {
    
    // e se il secondo operando è una costante su 9 bit
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
      if (isInt<9>(CN->getSExtValue())) {
        // e se il primo operando è il FrameIndex
        if (FrameIndexSDNode *FIN =
                dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
          // Constant offset from frame ref.
          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
        } else {
          // altrimenti la base è data dal primo operando
          Base = Addr.getOperand(0);
        }
        // l'offset è dato dal valore di Addr, trasformato in una costante
        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(Addr),
                                           MVT::i32);
        return true;
      }
    }
  }
  Base = Addr;
  Offset = CurDAG->getTargetConstant(0, SDLoc(Addr), MVT::i32);
  return true;
}

// funzione di hook principale usate per trasformare i nodi (IR) in
// nodi macchina
void NaplesPUDAGToDAGISel::Select(SDNode *N) {
 SDLoc DL(N);
 if (N->isMachineOpcode())
   return; // Already selected.

  // XXXInstrInfo.td also generates (in XXXGenDAGISel.inc) the SelectCode method
  // that is used to call the appropriate processing method for an
  // instruction.
  SelectCode(N);
}

/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
/// inline asm expressions.
bool NaplesPUDAGToDAGISel::SelectInlineAsmMemoryOperand(
    const SDValue &Op, unsigned ConstraintCode, std::vector<SDValue> &OutOps) {
  SDValue Op0, Op1;
  switch (ConstraintCode) {
  default:
    return true;

  case 'm': // memory
    SelectADDRri(Op, Op0, Op1);
    break;

  }

  OutOps.push_back(Op0);
  OutOps.push_back(Op1);
  return false;
}

FunctionPass *llvm::createNaplesPUISelDag(NaplesPUTargetMachine &TM) {
  return new NaplesPUDAGToDAGISel(TM);
}
